from fastapi import FastAPI, HTTPException, Depends, Header, WebSocket, WebSocketDisconnect, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from motor.motor_asyncio import AsyncIOMotorClient
from passlib.hash import bcrypt
from jose import jwt, JWTError
from datetime import datetime, timedelta
from typing import Optional, List
from bson import ObjectId
from gridfs import GridFS
from typing import Dict
import os
from fastapi.responses import FileResponse
import shutil
import subprocess

app = FastAPI()

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)
import secrets

JWT_SECRET_KEY = secrets.token_urlsafe(32)


# MongoDB connection setup
MONGODB_URL = "mongodb://137.184.227.11:27017/userauth"

async def connect_to_mongodb():
    client = AsyncIOMotorClient(MONGODB_URL)
    return client

# Database setup
users_db = {}

# Endpoint to serve the file generated by loadMongo.py
@app.get("/refreshed_file")
async def get_refreshed_file():
    return FileResponse("refreshed_data.txt")

# Function to periodically execute loadMongo.py
def run_load_mongo():
    while True:
        try:
            subprocess.run(["python3", "loadMongo.py"])
        except Exception as e:
            print("Error running loadMongo.py:", e)
        # Sleep for 5 seconds before running again
        time.sleep(30)

# Run the function in a separate thread when the FastAPI application starts
import threading
import time

thread = threading.Thread(target=run_load_mongo)
thread.start()

#UserModel
class User(BaseModel):
    email: str
class User(BaseModel):
    email: str
    password: str
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None

UPLOADS_DIR = "/root/A04/candyAPI/Photos/uploads"

@app.post("/upload")
async def upload_file(file: UploadFile = File(...)):
    try:
        # Create directories if they don't exist
        os.makedirs("Photos/uploads", exist_ok=True)
        file_location = os.path.join("Photos", "uploads", file.filename)
        with open(file_location, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
        return {"message": "File uploaded successfully", "file_path": file_location}
    except Exception as e:
        return {"error": str(e)}

@app.get("/photos", response_model=List[str])
async def get_all_photo_names():
    try:
        photo_files = os.listdir(UPLOADS_DIR)
        return photo_files
    except Exception as e:
        raise HTTPException(status_code=500, detail="Failed to retrieve photo names")

@app.get("/photos/{photo_name}")
async def get_photo(photo_name: str):
    try:
        photo_path = os.path.join(UPLOADS_DIR, photo_name)
        return FileResponse(photo_path)
    except Exception as e:
        raise HTTPException(status_code=404, detail="Photo not found")




# Root endpoint
@app.get("/")
async def read_root():
    return {"message": "Welcome to the authentication service"}

# User registration endpoint
@app.post("/register")
async def register_user(user: User):
    mongodb_client = await connect_to_mongodb()
    db = mongodb_client["userauth"]
    users_collection = db["users"]

    if await users_collection.count_documents({"email": user.email}) > 0:
        raise HTTPException(status_code=400, detail="Email already registered")

    hashed_password = bcrypt.hash(user.password)
    user_data = {"email": user.email, "hashed_password": hashed_password}
    result = await users_collection.insert_one(user_data)

    return {"message": "User registered successfully"}

# User login endpoint
@app.post("/login")
async def login_user(user: User):
    mongodb_client = await connect_to_mongodb()
 db = mongodb_client["userauth"]
    users_collection = db["users"]

    user_data = await users_collection.find_one({"email": user.email})
    if user_data is None:
        raise HTTPException(status_code=401, detail="Invalid credentials")

    hashed_password = user_data["hashed_password"]
    if not bcrypt.verify(user.password, hashed_password):
        raise HTTPException(status_code=401, detail="Invalid credentials")

    token = jwt.encode(
        {"sub": user.email, "exp": datetime.utcnow() + timedelta(minutes=30)},
        JWT_SECRET_KEY,
        algorithm="HS256"
    )
    return {"token": token}

# Token retrieval dependency
async def get_token(authorization: str = Header(...)):
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Invalid authorization header")
    token = authorization.split()[1]
    return token

async def authenticate_user(token: str = Depends(get_token)):
    try:
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=["HS256"])
        email = payload["sub"]
        return email
    except (JWTError, KeyError):
        raise HTTPException(status_code=401, detail="Invalid token")

# Endpoint to retrieve user locations
@app.get("/user_locations")
async def get_user_locations():
    mongodb_client = await connect_to_mongodb()
    db = mongodb_client["userauth"]
    users_collection = db["users"]

    # Retrieve all users' locations from the database
    user_locations = []
    async for user_data in users_collection.find({"first_name": {"$exists": True}}):
        if "latitude" in user_data and "longitude" in user_data:
            user_locations.append({
                "first_name": user_data["first_name"],
                "latitude": user_data["latitude"],
                "longitude": user_data["longitude"]
            })

    return user_locations

class FirstNameUpdateRequest(BaseModel):
    first_name: str

# GET endpoint to fetch the user's first name
@app.get("/profile/first_name")
async def get_user_first_name(email: str = Depends(authenticate_user)):
    mongodb_client = await connect_to_mongodb()
    db = mongodb_client["userauth"]
    users_collection = db["users"]

    user_data = await users_collection.find_one({"email": email})
    if user_data:
        first_name = user_data.get("first_name")
        if first_name:
 return {"first_name": first_name}
        else:
            raise HTTPException(status_code=404, detail="First name not found for this user")
    else:
        raise HTTPException(status_code=404, detail="User not found")

# Update the endpoint to accept the first_name in the request body
@app.put("/profile/first_name")
async def update_user_first_name(first_name_request: FirstNameUpdateRequest, authorization: str = Header(...)):
    # Check if the authorization header is present and starts with "Bearer "
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Invalid authorization header")

    # Extract the JWT token from the authorization header
    token = authorization.split()[1]

    try:
        # Decode the JWT token to extract the user's email
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=["HS256"])
        email = payload["sub"]
    except (JWTError, KeyError):
        raise HTTPException(status_code=401, detail="Invalid token")

    mongodb_client = await connect_to_mongodb()
    db = mongodb_client["userauth"]
    users_collection = db["users"]

    result = await users_collection.update_one(
        {"email": email},
        {"$set": {"first_name": first_name_request.first_name}}
    )

    if result.modified_count == 1:
        return {"message": "User first name updated successfully"}
    else:
        raise HTTPException(status_code=404, detail="User not found")

@app.get("/profile/last_name")
async def get_user_last_name(email: str = Depends(authenticate_user)):
    mongodb_client = await connect_to_mongodb()
    db = mongodb_client["userauth"]
    users_collection = db["users"]

    user_data = await users_collection.find_one({"email": email})
    if user_data:
        last_name = user_data.get("last_name")
        if last_name:
            return {"last_name": last_name}
        else:
            raise HTTPException(status_code=404, detail="Last name not found for this user")
    else:
        raise HTTPException(status_code=404, detail="User not found")

class LastNameUpdateRequest(BaseModel):
    last_name: str

# Update user's last name
@app.put("/profile/last_name")
async def update_user_last_name(last_name_request: LastNameUpdateRequest, authorization: str = Header(...)):
    # Check if the authorization header is present and starts with "Bearer "
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Invalid authorization header")

    # Extract the JWT token from the authorization header
    token = authorization.split()[1]
 try:
        # Decode the JWT token to extract the user's email
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=["HS256"])
        email = payload["sub"]
    except (JWTError, KeyError):
        raise HTTPException(status_code=401, detail="Invalid token")

    mongodb_client = await connect_to_mongodb()
    db = mongodb_client["userauth"]
    users_collection = db["users"]

    result = await users_collection.update_one(
        {"email": email},
        {"$set": {"last_name": last_name_request.last_name}}
    )

    if result.modified_count == 1:
        return {"message": "User last name updated successfully"}
    else:
        raise HTTPException(status_code=404, detail="User not found")



# Protected endpoint
@app.get("/protected")
async def protected_endpoint(token: str = Depends(get_token)):
    mongodb_client = await connect_to_mongodb()
    db = mongodb_client["userauth"]
    users_collection = db["users"]

    try:
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=["HS256"])
        user_email = payload.get("sub")
        user_data = await users_collection.find_one({"email": user_email})
        if user_data is None:
            raise HTTPException(status_code=401, detail="User not found")
        return {"message": "Protected endpoint accessed successfully", "user_email": user_email}
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

# WebSocket manager
class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}

    async def connect(self, user_id: str, websocket: WebSocket):
        await websocket.accept()
        self.active_connections[user_id] = websocket

    def disconnect(self, user_id: str):
        del self.active_connections[user_id]

    async def send_personal_message(self, user_id: str, message: dict):
        await self.active_connections[user_id].send_json(message)

    async def broadcast_message(self, message: dict):
        for connection in self.active_connections.values():
            await connection.send_json(message)

manager = ConnectionManager()

async def handle_message_broadcast(user_id, message):
    try:
        await manager.broadcast_message(message)
    except WebSocketDisconnect:
        # Handle WebSocket disconnection
        manager.disconnect(user_id)
    except (JWTError, KeyError):
        # Handle JWT token decoding errors
        raise HTTPException(status_code=401, detail="Invalid token")

# Function to get user info from the database
async def get_user_info(user_id: str):
    mongodb_client = await connect_to_mongodb()
    db = mongodb_client["userauth"]
    users_collection = db["users"]
    user_data = await users_collection.find_one({"_id": user_id})
    return user_data

# Storing message in the database with user ID
async def store_message(user_id: str, message: dict):
    mongodb_client = await connect_to_mongodb()
    db = mongodb_client["userauth"]
    messages_collection = db["messages"]
    message["user_id"] = user_id  # Add the user ID to the message
    await messages_collection.insert_one(message)

# Models
class ChatMessage(BaseModel):
    sender: str
    content: str

class FileUploadResponse(BaseModel):
    file_id: str

# Routes
@app.post("/messages/send")
async def send_message(message: ChatMessage):
    db = await get_db()
    message_dict = message.dict()
    await db.messages.insert_one(message_dict)
    await manager.broadcast_message(message_dict)
    return {"message": "Message sent successfully"}

@app.get("/messages")
async def get_messages():
    db = await get_db()
    messages = await db.messages.find().to_list(length=None)
    return messages

@app.post("/files/upload/")
async def upload_file(file: UploadFile = File(...)):
    fs = GridFS(await get_db(), collection="files")
    file_id = await fs.put(file.file, filename=file.filename)
    return {"file_id": str(file_id)}

@app.get("/files/{file_id}")
async def get_file(file_id: str):
    fs = GridFS(await get_db(), collection="files")
    file = await fs.get(ObjectId(file_id))
    content = await file.read()
    return content

async def get_db():
    db_client = await connect_to_mongodb()
    return db_client["userauth"]


# Function to get user info from the database
async def get_user_info(user_id: str):
    mongodb_client = await connect_to_mongodb()
    db = mongodb_client["userauth"]
users_collection = db["users"]
    user_data = await users_collection.find_one({"_id": user_id})
    return user_data

# Storing message in the database with user ID
async def store_message(user_id: str, message: dict):
    mongodb_client = await connect_to_mongodb()
    db = mongodb_client["userauth"]
    messages_collection = db["messages"]
    message["user_id"] = user_id  # Add the user ID to the message
    await messages_collection.insert_one(message)

# Models
class ChatMessage(BaseModel):
    sender: str
    content: str

class FileUploadResponse(BaseModel):
    file_id: str

# Routes
@app.post("/messages/send")
async def send_message(message: ChatMessage):
    db = await get_db()
    message_dict = message.dict()
    await db.messages.insert_one(message_dict)
    await manager.broadcast_message(message_dict)
    return {"message": "Message sent successfully"}

@app.get("/messages")
async def get_messages():
    db = await get_db()
    messages = await db.messages.find().to_list(length=None)
    return messages

@app.post("/files/upload/")
async def upload_file(file: UploadFile = File(...)):
    fs = GridFS(await get_db(), collection="files")
    file_id = await fs.put(file.file, filename=file.filename)
    return {"file_id": str(file_id)}

@app.get("/files/{file_id}")
async def get_file(file_id: str):
    fs = GridFS(await get_db(), collection="files")
    file = await fs.get(ObjectId(file_id))
    content = await file.read()
    return content

async def get_db():
    db_client = await connect_to_mongodb()
    return db_client["userauth"]

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="137.184.227.11", port=8085)